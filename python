"""
APG-RRT on a satellite map (no tkinter).
- Trees (RRT graph) are drawn in RED.
- Raw path (first found) drawn in MAGENTA (thin).
- Best (shortest) smoothed path drawn in BLACK (thick).
Usage:
    python map_apg_rrt_no_tk.py

Inputs (console prompts):
 - Map image path (top-down satellite)
 - Map georef bounds: lat_min lat_max lon_min lon_max
 - Start GPS lat lon
 - Goal GPS lat lon

Notes:
 - Tweak thresholds if road detection misses roads on your map.
 - No external map API; everything runs locally on image.
"""
import cv2
import numpy as np
import math
import random
import sys
from pathlib import Path

# -------------------------
# Utility: GPS <-> Pixel conversion
# -------------------------
def latlon_to_pixel(lat, lon, bounds, img_shape):
    lat_min, lat_max, lon_min, lon_max = bounds
    h, w = img_shape[:2]
    if lat_max == lat_min or lon_max == lon_min:
        raise ValueError("Invalid map bounds (zero size).")
    x = (lon - lon_min) / (lon_max - lon_min) * (w - 1)
    y = (lat_max - lat) / (lat_max - lat_min) * (h - 1)
    return (int(round(x)), int(round(y)))

# -------------------------
# Road mask extraction from satellite image (HSV + morphology)
# -------------------------
def build_road_mask(img):
    """
    Return binary mask where roads are 255 and others 0.
    This heuristics works on many satellite images: roads often low-saturation, relatively bright.
    Tweak HSV thresholds if needed for your image.
    """
    # Resize for speed if huge
    h, w = img.shape[:2]
    scale = 1.0
    if max(h, w) > 1600:
        scale = 1600.0 / max(h, w)
        img_small = cv2.resize(img, (int(w*scale), int(h*scale)), interpolation=cv2.INTER_AREA)
    else:
        img_small = img.copy()

    hsv = cv2.cvtColor(img_small, cv2.COLOR_BGR2HSV)
    hch, sch, vch = cv2.split(hsv)

    # Heuristic: roads usually low/medium saturation and moderate-high brightness
    # Tune these thresholds for your map style if needed
    sat_th_low = 0
    sat_th_high = 90
    val_th = 120

    mask1 = cv2.inRange(hsv, (0, sat_th_low, val_th), (179, sat_th_high, 255))

    # Also include lighter gray-ish roads with slightly higher saturation but neutral hue:
    # use a lightness-based threshold from grayscale
    gray = cv2.cvtColor(img_small, cv2.COLOR_BGR2GRAY)
    _, mask2 = cv2.threshold(gray, 140, 255, cv2.THRESH_BINARY)

    # Combine masks
    mask = cv2.bitwise_or(mask1, mask2)

    # Morphological cleanup
    k1 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k1, iterations=1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, k1, iterations=2)

    # Upscale mask to original size if resized
    if scale != 1.0:
        mask = cv2.resize(mask, (w, h), interpolation=cv2.INTER_NEAREST)
        _, mask = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)

    # Optional: remove small blobs (noise)
    nb_components, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)
    min_area = 200  # tune
    cleaned = np.zeros_like(mask)
    for i in range(1, nb_components):
        if stats[i, cv2.CC_STAT_AREA] >= min_area:
            cleaned[labels == i] = 255

    return cleaned

# -------------------------
# Center biased sampling using distance transform weights
# -------------------------
def build_sampling_candidates(road_mask):
    ys, xs = np.nonzero(road_mask)
    if len(xs) == 0:
        return None, None
    # distance transform to prefer center pixels
    dist = cv2.distanceTransform(road_mask, cv2.DIST_L2, 5)
    weights = dist[ys, xs].astype(np.float64)
    # small epsilon
    weights += 1e-6
    # normalize to sum=1
    weights /= weights.sum()
    candidates = list(zip(xs.tolist(), ys.tolist()))
    weights = weights.tolist()
    return candidates, weights

def weighted_random_choice(candidates, weights):
    # numpy choice is convenient
    idx = np.random.choice(len(candidates), p=weights)
    return candidates[idx]

# -------------------------
# Collision & RRT planner (APG-RRT)
# -------------------------
def collision_free(pt1, pt2, free_mask):
    x1, y1 = pt1; x2, y2 = pt2
    dist = int(math.hypot(x2 - x1, y2 - y1))
    if dist == 0:
        return 0 <= x1 < free_mask.shape[1] and 0 <= y1 < free_mask.shape[0] and free_mask[y1, x1] > 0
    steps = max(1, dist // 3)
    for i in range(steps + 1):
        t = i / steps
        x = int(round(x1 + (x2 - x1) * t))
        y = int(round(y1 + (y2 - y1) * t))
        if not (0 <= x < free_mask.shape[1] and 0 <= y < free_mask.shape[0]):
            return False
        if free_mask[y, x] == 0:
            return False
    return True

def rrt_planner_apg(start, goal, free_mask, candidates=None, weights=None,
                    max_iter=1500, step_size=30, goal_sample_rate=0.12):
    h, w = free_mask.shape[:2]
    nodes = [start]
    parent = {0: None}

    def nearest_idx(pt):
        best_i, best_d = 0, float('inf')
        for i, n in enumerate(nodes):
            d = (n[0]-pt[0])**2 + (n[1]-pt[1])**2
            if d < best_d:
                best_d, best_i = d, i
        return best_i

    for it in range(max_iter):
        if random.random() < goal_sample_rate:
            sample = goal
        else:
            if candidates is not None and weights is not None:
                sample = weighted_random_choice(candidates, weights)
            else:
                sample = (random.randint(0, w-1), random.randint(0, h-1))

        nid = nearest_idx(sample)
        nx, ny = nodes[nid]
        dx, dy = sample[0] - nx, sample[1] - ny
        dist = math.hypot(dx, dy)
        if dist == 0:
            continue
        step = min(step_size, dist)
        theta = math.atan2(dy, dx)
        newx = int(round(nx + step * math.cos(theta)))
        newy = int(round(ny + step * math.sin(theta)))
        if not (0 <= newx < w and 0 <= newy < h):
            continue
        if not collision_free((nx, ny), (newx, newy), free_mask):
            continue
        nodes.append((newx, newy))
        parent[len(nodes)-1] = nid

        # success if can connect to goal
        if math.hypot(newx - goal[0], newy - goal[1]) <= step_size and collision_free((newx, newy), goal, free_mask):
            # build path
            path = [goal, (newx, newy)]
            cur = len(nodes)-1
            while cur is not None:
                path.append(nodes[cur])
                cur = parent[cur]
            path.reverse()
            return path, nodes, parent
    return None, nodes, parent

# -------------------------
# Path utilities: length and smoothing (Chaikin)
# -------------------------
def path_length(path):
    s = 0.0
    for i in range(len(path)-1):
        s += math.hypot(path[i+1][0]-path[i][0], path[i+1][1]-path[i][1])
    return s

def chaikin_smooth(path, iterations=3):
    if path is None or len(path) < 3:
        return path
    pts = [tuple(p) for p in path]
    for _ in range(iterations):
        new_pts = [pts[0]]
        for i in range(len(pts)-1):
            p0 = np.array(pts[i], dtype=float)
            p1 = np.array(pts[i+1], dtype=float)
            q = 0.75 * p0 + 0.25 * p1
            r = 0.25 * p0 + 0.75 * p1
            new_pts.append(tuple(q.tolist()))
            new_pts.append(tuple(r.tolist()))
        new_pts.append(pts[-1])
        pts = new_pts
    return [(int(round(x)), int(round(y))) for x,y in pts]

# -------------------------
# Drawing helpers
# -------------------------
def draw_rrt_tree(img, nodes, parent, color=(0,0,255)):
    # color BGR; user wanted trees red -> (0,0,255)
    for i, n in enumerate(nodes):
        p = parent.get(i)
        if p is None: continue
        x1,y1 = nodes[p]; x2,y2 = n
        cv2.line(img, (x1,y1), (x2,y2), color, 1)

def draw_path(img, path, color=(255,0,255), thickness=2):
    if path is None: return img
    for i in range(len(path)-1):
        cv2.line(img, path[i], path[i+1], color, thickness)
    return img

# -------------------------
# Main
# -------------------------
def main():
    random.seed(0)
    np.random.seed(0)

    print("=== APG-RRT on satellite map (road-biased sampling) ===")
    map_path = input("Enter map image path (or press Enter to use 'map.png' in current dir): ").strip()
    if map_path == "":
        map_path = "map.png"
    if not Path(map_path).exists():
        print("Map file not found:", map_path)
        return

    # load map
    img = cv2.imread(map_path)
    if img is None:
        print("Failed to read image. Check path and file.")
        return
    h, w = img.shape[:2]
    print(f"Map loaded: {w}x{h} pixels")

    # bounds input
    print("Enter map georeference bounds as: lat_min lat_max lon_min lon_max")
    b = input("Bounds: ").strip().split()
    if len(b) != 4:
        print("Invalid bounds, need 4 numbers.")
        return
    bounds = tuple(map(float, b))

    # start & goal GPS
    print("Enter start GPS (lat lon):")
    s = input().strip().split()
    print("Enter goal GPS (lat lon):")
    g = input().strip().split()
    if len(s) != 2 or len(g) != 2:
        print("Invalid start/goal.")
        return
    s_lat, s_lon = map(float, s); g_lat, g_lon = map(float, g)

    start = latlon_to_pixel(s_lat, s_lon, bounds, (h,w))
    goal  = latlon_to_pixel(g_lat, g_lon, bounds, (h,w))
    print("Start pixel:", start, "Goal pixel:", goal)

    # build road mask
    road_mask = build_road_mask(img)
    # optional debug window:
    # cv2.imshow("Road mask", road_mask); cv2.waitKey(0)

    # prepare sampling candidates weighted by distance transform (center bias)
    dist = cv2.distanceTransform(road_mask, cv2.DIST_L2, 5)
    # zero out outside-road
    dist[road_mask==0] = 0.0
    candidates, weights = build_sampling_candidates(road_mask)
    if candidates is None:
        print("No road pixels detected by mask. Try increasing sensitivity or use different map.")
        cv2.imshow("Map", img)
        cv2.waitKey(0)
        return

    # ensure start & goal lie within road area; if not, nudge to nearest road pixel
    def nudge_to_road(pt):
        x,y = pt
        if 0 <= x < w and 0 <= y < h and road_mask[y,x] > 0:
            return pt
        # find nearest nonzero in dist by brute force search in increasing radius
        for r in range(1,300,5):
            for ang in np.linspace(0, 2*math.pi, 36):
                nx = int(round(x + r*math.cos(ang))); ny = int(round(y + r*math.sin(ang)))
                if 0 <= nx < w and 0 <= ny < h and road_mask[ny,nx] > 0:
                    return (nx, ny)
        return pt

    start = nudge_to_road(start)
    goal = nudge_to_road(goal)
    print("Nudged Start:", start, "Nudged Goal:", goal)

    # run APG-RRT multiple times and keep shortest path found
    best_path = None
    best_len = float('inf')
    best_nodes = None
    best_parent = None
    trials = 6
    print("Running APG-RRT trials (this may take a few seconds)...")
    for t in range(trials):
        # vary random seed per trial
        random.seed(t + 100)
        np.random.seed(t + 100)
        path, nodes, parent = rrt_planner_apg(start, goal, road_mask, candidates=candidates, weights=weights,
                                              max_iter=1800, step_size=40, goal_sample_rate=0.12)
        if path is not None:
            L = path_length(path)
            print(f"Trial {t}: path length {L:.1f}, nodes {len(nodes)}")
            if L < best_len:
                best_len = L
                best_path = path
                best_nodes = nodes
                best_parent = parent
        else:
            print(f"Trial {t}: no path found (nodes {len(nodes)})")

    # visualization
    vis = img.copy()
    # overlay semi-transparent road mask for clarity
    overlay = vis.copy()
    vis[road_mask==255] = (vis[road_mask==255] * 0.6 + np.array([0,200,0], dtype=np.uint8) * 0.4)  # tint road slightly green

    if best_nodes:
        # draw tree red
        draw_rrt_tree(vis, best_nodes, best_parent, color=(0,0,255))  # BGR red
    if best_path:
        # draw raw path thin magenta
        draw_path(vis, best_path, color=(255,0,255), thickness=2)
        # smooth best path via Chaikin
        smooth = chaikin_smooth(best_path, iterations=4)
        # re-evaluate length after smoothing
        Ls = path_length(smooth)
        print("Best path length:", best_len, "Smoothed length:", Ls)
        # draw smoothed path as thick black (final)
        draw_path(vis, smooth, color=(0,0,0), thickness=6)
        # mark start/goal
        cv2.circle(vis, best_path[0], 8, (0,255,0), -1)  # start yellow-green
        cv2.circle(vis, best_path[-1], 8, (0,0,255), -1) # goal red
    else:
        print("No path found in any trial. Try increasing max_iter, step_size, or adjust road mask.")
        cv2.circle(vis, start, 8, (0,255,0), -1)
        cv2.circle(vis, goal, 8, (0,0,255), -1)

    cv2.imshow("APG-RRT Road-Following Result", vis)
    cv2.imwrite("apg_rrt_result.png", vis)
    print("Result saved to apg_rrt_result.png")
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
